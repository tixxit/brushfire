package com.stripe.brushfire
package finatra

import scala.collection.JavaConverters._

import com.twitter.bijection.{ Injection, Codec, StringCodec }
import com.twitter.bijection.json.JsonNodeInjection
import com.twitter.bijection.json.JsonNodeInjection._
import com.twitter.util.Future
import scala.util.{ Try, Success, Failure }

import org.codehaus.jackson.JsonNode

import JsonNodeImplicits._

/**
 * Convenience methods to construct injections for [[ForestModel]].
 *
 * @param voter   the Voter to use in the forest model
 * @param extract the function to extract features from a parameter map
 */
class ForestModelInjections[K, V, T, P](
  extract: Map[String, String] => Try[Map[K, V]],
  voter: Voter[T, Future[P]]) {

  /**
   * Returns a `JsonNode` injection for forest models.
   */
  def jsonInjection(implicit inj: JsonNodeInjection[Tree[K, V, T]]): JsonNodeInjection[ForestModel[K, V, T, P]] =
    new ForestJsonInjection

  /**
   * Returns a `Codec` for [[ForestModel]]s based on UTF-8 encoded TSVs, as
   * generated by Brushfire's Scalding job.
   */
  def scaldingCodec(implicit inj: Injection[Tree[K, V, T], String]): Injection[ForestModel[K, V, T, P], Array[Byte]] =
    new ForestCodec

  final class ForestJsonInjection(implicit inj: Injection[Tree[K, V, T], JsonNode]) extends JsonNodeInjection[ForestModel[K, V, T, P]] {
    def apply(model: ForestModel[K, V, T, P]): JsonNode = {
      val trees: Iterable[JsonNode] = model.trees.toList.map { case (index, tree) =>
        toJsonNode(Map(
          "index" -> toJsonNode(index),
          "tree" -> inj(tree)))
      }
      val metadata: JsonNode = toJsonNode(model.metadata)
      toJsonNode {
        Map("metadata" -> metadata, "trees" -> toJsonNode(trees.toSeq))
      }
    }

    override def invert(node: JsonNode): Try[ForestModel[K, V, T, P]] = for {
      metadataNode <- node.tryField("metadata")
      metadata     <- fromJsonNode[ModelMetadata](metadataNode)
      treesNode    <- node.tryField("trees")
      trees        <- parseTrees(treesNode)
    } yield {
      ForestModel(trees, voter, metadata, extract)
    }

    private def parseTrees(node: JsonNode): Try[Map[Int, Tree[K, V, T]]] =
      Try.sequence(node.getElements.asScala.map { row =>
        for {
          indexNode <- row.tryField("index")
          index     <- indexNode.tryAsInt
          treeNode  <- row.tryField("tree")
          tree      <- inj.invert(treeNode)
        } yield {
          index -> tree
        }
      })(collection.breakOut)
  }

  final class ForestCodec(implicit inj: Injection[Tree[K, V, T], String]) extends Injection[ForestModel[K, V, T, P], Array[Byte]] {
    def apply(model: ForestModel[K, V, T, P]): Array[Byte] = {
      val rows = model.trees.toVector.sortBy(_._1).map { case (row, tree) =>
        row.toString + "\t" + inj(tree)
      }
      StringCodec.utf8(rows.mkString("\n"))
    }

    override def invert(bytes: Array[Byte]): Try[ForestModel[K, V, T, P]] = for {
      tsv   <- StringCodec.utf8.invert(bytes)
      trees <- Try {
                 tsv.split("\n").map(_.split("\t", 2)).map { case Array(row, tree) =>
                   inj.invert(tree).map(row.toInt -> _).get
                 }.toMap
               }
    } yield {
      ForestModel(trees, voter, ModelMetadata(None), extract)
    }
  }
}
